---
layout: post
title: AVL part 1 - Tasteful BST
---

(This AVL series is just a little documentation on my study for Data Structure, or general C, for now I want to implement AVL Tree in C)

A Tasteful code

In the morning I watched Linus Torvalds in TED, talking about his life, Linux, and he talked about tasteful code, so basically tasteful code is an optimized code, and honestly I think makes the code unreadable and shit, but somehow I understand why, to achieve this optimized code for me, I need solve the problem like million times to get the big pattern, because by nature, you write an optimized code when you understand the problem deeply.

Okay, back to the topic.

I've wrote a Binary Search Tree implementation in C several times before, before I even know how to delete a node properly by searching successor within the subtree and all that crap, because I learnt BST before I even got Data Structure course in college. So yeah, I really familiar with BST, but not with the 'good' BST.

So I wrote everything from scratch, and here's the result

{% highlight c %}
typedef struct node
{
	int value;
	struct node *left, *right;
} Node;
{% endhighlight %}

starts from the node struct, I just make a simple one, no need to have a good real life example of struct of data like students or something.

{% highlight c %}
void addNode(int _value)
{
	Node *newNode = malloc(sizeof(Node));
	newNode->value = _value;
	newNode->left = NULL;
	newNode->right = NULL;

	addNodeRecursive(&head, newNode);
}

void addNodeRecursive(Node **curr, Node *newNode)
{
	if(*curr!=NULL)
	{
		if((*curr)->value>newNode->value)
		{
			addNodeRecursive(&((*curr)->left), newNode);
		}
		else
		{
			addNodeRecursive(&((*curr)->right), newNode);
		}
	}
	else
	{
		*curr = newNode;
	}
}
{% endhighlight %}

Function for adding a node, it's pretty much the same with everybody else I think? the double-pointer and recursive approach is a normal thing to do, and something to add here that I want to implement AVL Tree for the next round, so I think the best approach is recursive because I have to trace back to the root to rebalance the tree if there is a unbalanced subtree. I haven't made the proper implementation of AVL Tree before so I hope this won't ended up as a piece of bloat garbage.

For those of you who unfamiliar with double pointer approach, so basically the idea behind the double-pointer is the function take a 'path' as an argument (more accurately, a pointer to the 'path'), not the node itself, so in other words, if we want to build a house, the expression would be 'i build a house in address xxx' not 'i build a house next to mr.xxx's house', and one thing that makes the later expression is not a good statement is you have to know which next? is it it's left or it's right? What if the left side of mr.xxx's house is occupied and we just override the house with our house?

Okay, next is the important part

{% highlight c %}
void deleteNode(int _value)
{
	deleteNodeRecursive(&head, _value);
}

void deleteNodeRecursive(Node **curr, int _value)
{
	if((*curr)->value==_value)
	{
		Node *delNode = *curr;
		if((*curr)->left==NULL)
		{
			*curr = (*curr)->right;
		}
		else if((*curr)->right==NULL)
		{
			*curr = (*curr)->left;
		}
		else
		{
			successorDelete(&((*curr)->left), curr, (*curr)->left->left);
		}
		free(delNode);
		return;
	}
	if((*curr)->value>_value)
	{
		deleteNodeRecursive(&((*curr)->left), _value);
	}
	else
	{
		deleteNodeRecursive(&((*curr)->right), _value);
	}
}
{% endhighlight %}

Now here's the part that I optimize, in node deletion in BST, we need to know whether the node we wants to delete:
- don't have any child
- only have left child
- only have right child
- have both child
Okay, the first 3 is basically done by if and else if statement, but the 4th condition is a bit special snowflake, because we have to find the successor of the deleted node, there's no way a BST would operate correctly when a node is empty
